![](https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/229bbc47caf34f2290418447f30ad5f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-X5LmL5Lul6JKZ:q75.awebp?rk3s=f64ab15b&x-expires=1726280234&x-signature=U7x5IBo0%2BwITHIKd4PqOw80dXHM%3D)

# Rust 所有权与 Move：内存管理的艺术

# 一、所有权的机制

Rust 通过引入所有权系统来管理内存。

所有权的规则确保每个值都有一个唯一的所有者，当所有者离开作用域时，其持有的值就会被自动释放。这样就避免了内存泄漏和悬空指针的问题，同时也不需要在运行时进行垃圾回收，从而提高了程序的性能。

Move 语义是 Rust 所有权系统的一个重要组成部分。在 Rust 中，当一个值被移动时，所有权就从一个变量转移到了另一个变量。例如，将一个变量赋值给另一个变量时，就会发生 Move 操作，原来的变量将不再拥有该值的所有权。这种明确的所有权转移规则使得 Rust 能够在编译期就确保内存的安全性。

通过所有权和 Move 的结合，Rust 能够在不依赖垃圾回收机制的情况下，实现高效的内存管理。这不仅提高了程序的性能，还大大增强了程序的安全性，使得开发者能够更加放心地编写代码。

# 二、所有权的规则与特点

## （一）所有权的三条黄金法则

Rust 的所有权遵循三条简单但强大的规则：

**1、每个值都有一个所有者，就像每个物品都有一个主人一样**

在 Rust 中，一个值被创建后，就会有一个特定的变量成为它的所有者，负责管理它的生命周期。

例如，当我们创建一个字符串 let s = String::from("hello");，这里变量 s 就是这个字符串值的所有者。

**2、一个值在任何时候只能有一个所有者**

这确保了内存资源的明确归属，避免了多个变量同时对同一个值进行混乱的管理。

比如，当我们尝试将一个已经有所有者的值再次赋值给另一个变量时，所有权会发生转移。

let s1 = String::from("hello"); let s2 = s1;，此时，s2 成为了 "hello" 的所有者，s1 不再拥有所有权。

**3、当所有者离开作用域时，该值就会被丢弃**

Rust 会自动清理不再被所有者持有的值，这保证了内存的及时释放，防止内存泄漏。

例如，当一个函数中的局部变量离开函数作用域时，Rust 会自动释放这个变量所占用的内存资源。

## （二）变量作用域与所有权转移

变量的作用域对所有权有着重要的影响。

在 Rust 中，变量的作用域是指变量在程序中的有效范围。当一个变量进入作用域时，它可以被使用；当它离开作用域时，所有权可能会发生转移或者值会被自动释放。

例如，在赋值操作中，所有权会从一个变量转移到另一个变量。就像前面提到的
```rust
let s1 = String::from("hello"); 
let s2 = s1;
```
这里所有权从 s1 转移到了 s2。

在函数传参时，所有权也会发生转移。比如
```rust
fn takes_ownership(some_string: String) { 
    println!("{}", some_string); 
 }，
```
当我们调用这个函数 takes_ownership(s)，这里 s 的所有权转移到了函数参数 some_string。当函数执行完毕，some_string 离开作用域，其持有的值被释放。

函数返回值时同样会涉及所有权的转移。如果一个函数返回一个值，那么这个值的所有权就转移到了调用者。

## （三）克隆与拷贝的区别

在 Rust 中，克隆（深拷贝）和拷贝（浅拷贝）有着不同的应用场景和实现方式。

克隆是一种深拷贝操作，对于像 String 这样的复杂类型，使用 clone 方法可以复制一个值，包括它在堆上的数据。

例如 
```rust
let s1 = String::from("hello"); 
let s2 = s1.clone();
```
这里 s2 是 s1 的完全独立副本，它们在内存中拥有不同的存储位置。

而对于基本类型，如整数，赋值操作会自动进行拷贝（浅拷贝），因为它们存储在栈上。例如 let x = 5; let y = x;，这里 x 的值被拷贝给了 y，但它们实际上是同一个值在栈上的两个副本，由于基本类型占用空间小，这种拷贝操作快速且高效。

克隆适用于复杂类型，确保复制出完全独立的副本；拷贝适用于基本类型，快速在栈上复制值。

# 三、Move 的特点与作用

## （一）赋值与所有权转移

在 Rust 中，对于大多数类型而言，赋值操作会触发 Move 语义。

当一个变量被赋值给另一个变量时，原始变量将让渡所有权给目标变量，并变成未初始化状态。

例如
```rust
let s1 = String::from("hello"); let s2 = s1;
```
在这个例子中，s1 将 "hello" 的所有权转移给了 s2，此后 s1 处于未初始化状态，不能再被使用。这种所有权转移的机制确保了内存资源的明确归属，避免了多个变量同时对同一个值进行混乱的管理。

同时，Rust 在结尾的作用域结束处会自动调用 drop释放内存，如当 s2 离开作用域时，它所拥有的内存资源会被自动释放，避免了内存泄漏的问题。

## （二）实现 Copy 特性的影响

在 Rust 中，某些类型赋值会发生 Copy，不会发生Move操作。

整型、布尔类型、字符类型、浮点等基本类型在赋值时会自动进行拷贝，因为它们实现了 Copy 特性。

如果元组中包含的字段类型都实现了 Copy，那元组也是 Copy 类型。对于实现了 Copy 特性的值来说，赋值会生成一个新的副本，而不会发生转移并让原始变量变成未初始化的状态。

对于整数类型，数值直接存储在栈上，这些值的复制操作非常快，而 String 类型实际的数据部分存储在堆上，赋值过程采用深度拷贝的话，非常浪费性能。在整数的赋值过程中，并不会发生 move，而是直接复制了一份。

对于自定义类型，如果想要实现 Copy 特性，可以通过追加属性标记 #[derive(Copy)]，但要注意，Rust 自动会为代码派生 Copy 的前提是结构体或枚举的所有成员都实现了 Copy 特性。

例如，下面的代码就会编译失败：#[derive(Copy, Clone)]struct Numbers {nums: Vec}，因为 Vec 没有实现 Copy 特性。

# 四、所有权与 Move 的案例分析

## （一）Vec 类型的 Move 示例

在 Rust 中，Vec（动态数组）类型在赋值操作时会体现出所有权的转移和 Move 语义。例如：
```rust
let orders = vec!["183".to_string(), "136".to_string()];
let tmp_a = orders;
let tmp_b = orders;
```

这段代码会编译报错。原因是在给 tmp_a 赋值时，orders 的所有权发生了转移，此时 orders 变成未初始化状态。再给 tmp_b 赋值时，由于 orders 已经没有所有权，所以会报错。

如果想要进行深拷贝，可以使用 clone 方法。如下所示：
```rust
let orders = vec!["183".to_string(), "136".to_string()];
let tmp_a = orders.clone();
let tmp_b = orders.clone();
```

这样就可以避免所有权转移带来的问题，同时在内存中创建了两个独立的副本。

## （二）String 类型的 Move 与 Copy 尝试

对于 String 类型，同样在赋值操作时会发生所有权转移。例如：
```rust
let name: String = "neojos".to_string();
let tmp_a = name;let tmp_b = name;
```

会出现和 Vec 类型类似的编译错误。

尝试给 String 类型增加 Copy 属性的方法失败了。我们声明一个 String 的类型别名 CopyString，在 CopyString 上追加 Copy 属性，但编译不通过，因为 derive 属性标记只能应用于 struct、enum 和 union 类型上。

接着用结构体包装 String 的方式也失败了。定义一个结构体类型，结构体中包含一个 String 类型的字段，给这个结构体实现 Copy 属性，但代码仍然编译失败，因为结构体想要实现 Copy 属性，依赖于内部的字段类型都实现 Copy 属性，而 String 类型没有实现 Copy 属性。

# 五、所有权与 Move 的意义与展望

Rust 的所有权和 Move 在内存安全和并发安全方面具有极其重要的意义。

在内存安全方面，所有权系统确保每个值都有一个明确的所有者，当所有者离开作用域时，值会被自动释放，避免了内存泄漏和悬空指针的问题。

Move 语义进一步强化了所有权的转移规则，使得开发者能够在编译期就确定内存的管理方式，大大降低了运行时出现内存错误的风险。

在并发安全方面，Rust 的所有权规则和 Send、Sync 等特性为多线程编程提供了强大的保障。

一个值只能有一个所有者的规则，以及对可变引用的严格限制，使得在多线程环境下，不同线程之间对共享资源的访问更加安全。Move 语义也有助于避免在并发环境下出现数据竞争和不一致的情况。

总之，Rust 的所有权和 Move 不仅在当前为开发者提供了一种安全、高效的编程方式，而且在未来也有望对编程语言的发展产生积极的影响。
